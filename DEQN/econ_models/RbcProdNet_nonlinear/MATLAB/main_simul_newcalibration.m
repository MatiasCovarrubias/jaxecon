%%% This code runs the calibration and dynare solution for Carvalho, Covarrubias and Nu�o (2022), with new calibration targets.
%%% The new calibration targets are: aggregate GDP volatility, aggregate GDP autocorrelation, and secotral GDP comovement. 
%%% To match this parameter, we calibrate the variance covariance matrix of value added TFP shocks, and the persistence. 
%%% For the new variance covariance matriz, we assume all the shocks are identically distributed, so we have three parameters: var_Sigma_A, cov_Sigma_A, rho.
%%% As a starting point, we will take Sigma_A and rho generated by sectoral Solow residuals, and we will se the fit.
%%% We are also interested in fit alogn the following empricial targets: average sectoral investment volatility and labor volatility.

clear; 
clearvars -global;    
clc; 

% Options (change here)
save_exper_ind = 1; % 1 to save data  and graphs for the experiment.

% date = datetime('today', 'Format', 'yyyy-MM-dd');
date = "Nov12_25";
exp_label = "_newcalibration";
save_label = strcat(date, exp_label);

% optimization options
options  = optimset('Display','iter','TolX',1e-10,'TolFun',1e-10,'MaxFunEvals',10000000,'MaxIter',10000);

%% Calibration

%%%%% Calibration targets and Data based parameters %%%%%

load calibration_data.mat

%%%% Calibration data for 37 sectors and 71 years (some have 72). Variables have different dimensions.
% IOmat47bea = input-output matrix (37x37x72)
% depratbea = depreciation rate (37x72)
% capshbea = capital share (37x71)
% Cons47bea = consumption (72x37)
% GO47bea = gross output (72x37)
% VA47bea = value added (72x37)
% invmat = investment matrix (37x37x72)
% InvRaw = Investment raw data (71 x 37)
% EMP_raw = Labor raw data (71 x 37)
% VA_raw = Value added raw data (71 x 37)

dim=37;

%% Empirical Targets for Volatility Matching
fprintf('\n*** COMPUTING EMPIRICAL TARGETS ***\n');

empiricalTargets = struct();

InvRaw_temp = InvRaw;
EMP_raw_temp = EMP_raw;
VA_raw_temp = VA_raw;

epsilon = 1e-10;
InvRaw_temp(InvRaw_temp <= 0) = epsilon;
EMP_raw_temp(EMP_raw_temp <= 0) = epsilon;
VA_raw_temp(VA_raw_temp <= 0) = epsilon;

w_emp = mean(VA_raw_temp, 1);
weights_emp = w_emp ./ sum(w_emp);

% HP filter parameter (100 for annual data, 1600 for quarterly)
hp_lambda = 100;

% Compute HP-filtered log levels for sectoral VA
logVA = log(VA_raw_temp);
VA_hp_trend = zeros(size(logVA));
VA_hp_cycle = zeros(size(logVA));
for i = 1:size(logVA, 2)
    [VA_hp_trend(:,i), VA_hp_cycle(:,i)] = hpfilter(logVA(:,i), hp_lambda);
end

% HP-filtered aggregate VA (in logs)
VA_agg = sum(VA_raw_temp, 2);
logVA_agg = log(VA_agg);
[VA_agg_trend, VA_agg_cycle] = hpfilter(logVA_agg, hp_lambda);

% Target 1: Aggregate GDP volatility (std of HP-filtered log levels)
sigmaVA_agg = std(VA_agg_cycle);

% Target 2: Aggregate GDP autocorrelation (of HP-filtered log levels)
rho_VA_agg = corr(VA_agg_cycle(1:end-1), VA_agg_cycle(2:end));

% Target 3: Sectoral VA comovement (correlation of HP-filtered log levels)
corr_matrix_VA = corr(VA_hp_cycle);
n_sectors = size(corr_matrix_VA, 1);
upper_tri_idx = triu(true(n_sectors), 1);
pairwise_corrs = corr_matrix_VA(upper_tri_idx);
avg_pairwise_corr_VA = mean(pairwise_corrs);

% Targets 4-5: Investment and labor volatility (HP-filtered log levels)
logI = log(InvRaw_temp);
logL = log(EMP_raw_temp);
I_hp_cycle = zeros(size(logI));
L_hp_cycle = zeros(size(logL));
for i = 1:size(logI, 2)
    [~, I_hp_cycle(:,i)] = hpfilter(logI(:,i), hp_lambda);
    [~, L_hp_cycle(:,i)] = hpfilter(logL(:,i), hp_lambda);
end

sigmaIi = std(I_hp_cycle, 0, 1);
sigmaLi = std(L_hp_cycle, 0, 1);
sigmaI_emp = sum(weights_emp .* sigmaIi);
sigmaL_emp = sum(weights_emp .* sigmaLi);

empiricalTargets.sigmaI = sigmaI_emp;
empiricalTargets.sigmaL = sigmaL_emp;
empiricalTargets.sigmaVA_agg = sigmaVA_agg;
empiricalTargets.rho_VA_agg = rho_VA_agg;
empiricalTargets.avg_pairwise_corr_VA = avg_pairwise_corr_VA;
empiricalTargets.weights = weights_emp;
empiricalTargets.sigmaIi = sigmaIi;
empiricalTargets.sigmaLi = sigmaLi;
empiricalTargets.corr_matrix_VA = corr_matrix_VA;
empiricalTargets.hp_lambda = hp_lambda;
empiricalTargets.upper_tri_idx = upper_tri_idx;

fprintf('Target 1 - Aggregate GDP volatility (HP-filtered): %.4f\n', sigmaVA_agg);
fprintf('Target 2 - Aggregate GDP autocorrelation (HP-filtered): %.4f\n', rho_VA_agg);
fprintf('Target 3 - Sectoral VA average pairwise correlation (HP-filtered): %.4f\n', avg_pairwise_corr_VA);
fprintf('Target 4 - Value-added weighted investment volatility (HP-filtered): %.4f\n', sigmaI_emp);
fprintf('Target 5 - Value-added weighted labor volatility (HP-filtered): %.4f\n', sigmaL_emp);
fprintf('***************************\n\n');

% 

va_data = mean(VA47bea);
% Consumption Expenditure Shares (this one is OK)
conssh_data=mean(mean(Cons47bea,2)./repmat(sum(Cons47bea,2),1,dim))';
% conssh_data = 1/dim*ones(dim,1);

% Capital expenditure  shares
capshbea(capshbea<0.05)=0.05; % Account for some odd swings in capital shares that generate very low numbers
capsh_data=mean(capshbea,2); 
% capsh_mean = va_data*capsh_data/sum(va_data);
% capsh_data = capsh_mean * ones(dim,1);

% Value added share of gross output
vash_data=(mean(VA47bea./GO47bea))'; %Average Value added/Gross Output Ratio
go_data = mean(GO47bea);
% vash_mean = go_data*vash_data/sum(go_data);
% vash_data = vash_mean * ones(dim,1);

% Investment matrix
invnet_data = mean(invmat,3);
% invnet_data = eye(size(invnet_data));
invnet_data(invnet_data < 0.001) = 0.001;
invnet_data = invnet_data ./ sum(invnet_data, 1);

% Input-Output Matrix
ionet_data=mean(IOmat47bea./repmat(sum(IOmat47bea),[dim 1 1]),3);
% ionet_data = eye(size(ionet_data));
ionet_data(ionet_data < 0.001) = 0.001;
ionet_data = ionet_data ./ sum(ionet_data, 1);


%%%%% Externally calibrated parameters %%%%%

% Depreciation rates
dep_data = mean(depratbea,2); % Average implied depreciation rate by industry 1947-2018 (BEA fixed assets)
% dep_mean = va_data*dep_data/sum(va_data);
% dep_data = dep_mean * ones(37,1); % Average implied depreciation rate by industry 1947-2018 (BEA fixed assets)
params.delta = dep_data; % Average implied depreciation rate by industry 1947-2018 (BEA fixed assets)
% disp("Depreciation New");
% disp(params.delta);

% process for TFP
load TFP_process;

%% TFP Shock Calibration: Three Scalar Parameters
% We calibrate TFP shocks with homogeneous sectoral distributions:
% - vol_Sigma_A: diagonal elements of Sigma_A (volatility)
% - cov_Sigma_A: off-diagonal elements of Sigma_A (covariance)
% - rho: persistence (scalar for all sectors)

% Current calibration based on data:
modrho_mean = va_data*modrho/sum(va_data);
[Qv, Dv] = eig(modvcv);
eigenvalues=diag(Dv);
eigen_mean = va_data*eigenvalues/sum(va_data);
num_simulations = 1000;
simulated_data = mvnrnd(zeros(1, dim), modvcv, num_simulations);
std_devs = std(simulated_data)';
std_devs_mean = 2*va_data*std_devs/sum(va_data);

% Extract current calibration as scalars
rho_current = 0.4;
vol_Sigma_A_current = std_devs_mean^2;
cov_Sigma_A_current = 0.08 * vol_Sigma_A_current;

fprintf('\n*** CURRENT TFP SHOCK CALIBRATION ***\n');
fprintf('rho (persistence): %.4f\n', rho_current);
fprintf('vol_Sigma_A (variance): %.6f\n', vol_Sigma_A_current);
fprintf('cov_Sigma_A (covariance): %.6f\n', cov_Sigma_A_current);
fprintf('***************************\n\n');

% Set parameters based on scalar calibration
params.rho = rho_current * ones(dim,1);
params.Sigma_A = vol_Sigma_A_current * eye(dim) + cov_Sigma_A_current * (ones(dim) - eye(dim));

% Store scalar parameters for calibration
params.rho_scalar = rho_current;
params.vol_Sigma_A_scalar = vol_Sigma_A_current;
params.cov_Sigma_A_scalar = cov_Sigma_A_current;

% common values in literature
params.beta = 0.96;
params.eps_l = 0.5;
params.eps_c = 0.5;
params.theta = 1;

% desired elasticied of substitution (we will work towards them in params
% struct later)
sigma_c = 0.5;
sigma_m = 0.001;
sigma_q = 0.5; % we will recalibrate this later
sigma_y = 0.8; 
sigma_I = 0.5;
sigma_l = 0.5; % we will recalibrate this later

% useful parameteres for later
params.n_sectors = 37;
params.IRshock = 0.22;
% length of simulations
params.simul_T = 100;


% params.Sigma_A = modvcv;

% Capital adjustment and labor reallocation
params.phi = 2.5; % we will recalibrate this later

% expenditure shares (for matching)
params.conssh_data = conssh_data;
params.capsh_data = capsh_data;
params.vash_data = vash_data;
params.ionet_data = ionet_data;
params.invnet_data = invnet_data;

disp('*** FINISHED STORING PARAMETERS IN params STRUCTURE ***');

%% Solve Steady State under Cobb Douglas and high sigma_l
% elasticities of substitution
params.sigma_c = 0.5;
params.sigma_m = 0.99;
params.sigma_q = 0.99;
params.sigma_y = 0.99;
params.sigma_I = 0.99;
params.sigma_l = 0.99;
% Intesity shares in CD case
params.xi = conssh_data;
params.alpha = capsh_data;
params.mu = vash_data;
params.Gamma_M = ionet_data;
params.Gamma_I = invnet_data;

load SS_CDsolution_norm.mat
% sol_guess=[zeros([11*params.n_sectors,1])-1;0;-1;1];
sol_guess = sol_init;

% Assuming intensitiy shares are equal to expenditure shares
total_tic = tic;
fh_compStSt         = @(x) ProdNetRbc_SS(x,params, 0);
[sol_init,fval,exfl]  = fsolve(fh_compStSt,sol_guess,options);
[fx,ModData]        = ProdNetRbc_SS(sol_init,params,0);
elapsed_time = toc(total_tic);
fprintf('It took %.4f seconds to run.\n', elapsed_time);

if save_exper_ind==1
    save SS_CDsolution_norm.mat sol_init
end

disp('*** FINISHED SOLVING STEADY STATE WITH SIGMAS EQUAL TO 1 ***');


%% lower sigma_l

% Initial guess (from previous section or uncomment next line)
sol_guess = sol_init;

% loop over grid of values to get final answer
gridpoints = 8;
sigma_l_grid = linspace(0.9,sigma_l,gridpoints);
total_tic = tic;
for i = 1:gridpoints
    iteration_tic = tic;
    params.sigma_l = sigma_l_grid(i);
    fh_compStSt         = @(x) ProdNetRbc_SS(x,params, 0);
    [sol_init,fval,exfl]  = fsolve(fh_compStSt,sol_guess,options);
    [fx,ModData]        = ProdNetRbc_SS(sol_init,params,0);
    sol_guess = sol_init;
    disp(sprintf('For sigma_l = %0.2f : %s',params.sigma_l,ExitFlag(exfl)));
    iteration_time = toc(iteration_tic);
    fprintf('It took %.4f seconds to run iteration number %d \n', iteration_time,i);
end
elapsed_time = toc(total_tic);
fprintf('It took %.4f seconds to run this loop.\n', elapsed_time);
disp('*** FINISHED SOLVING STEADY STATE WITH LOW SIGMA_L***');

%% match expenditure shares for value added production and IO network (as an intermediate step)

% Intial guess
mu_guess = vash_data;
Gamma_M_guess = ionet_data(1:params.n_sectors-1, :);
Gamma_M_guess = Gamma_M_guess(:);
sol_guess = [sol_init;log(mu_guess);log(Gamma_M_guess)];

% loop over grid of values to get final answer
gridpoints = 8;
sigma_m_grid = linspace(0.99,sigma_m,gridpoints);
sigma_q_grid = linspace(0.99,sigma_q,gridpoints);
total_tic = tic;
for i = 1:gridpoints
    iteration_tic = tic;
    params.sigma_m = sigma_m_grid(i);
    params.sigma_q = sigma_q_grid(i);
    fh_compStSt         = @(x) ProdNetRbc_SS_vaioshares(x,params, 0);
    [sol_partial,fval,exfl]  = fsolve(fh_compStSt,sol_guess,options);
    [fx,ModData]        = ProdNetRbc_SS_vaioshares(sol_partial,params,0);
    sol_guess = sol_partial;
    disp(sprintf('For sigma_m = %0.2f and sigma_q = %0.2f : %s',params.sigma_m,params.sigma_q,ExitFlag(exfl)));
    iteration_time = toc(iteration_tic);
    fprintf('It took %.4f seconds to run iteration number %d \n', iteration_time,i);
end
elapsed_time = toc(total_tic);
fprintf('It took %.4f seconds to run this loop.\n', elapsed_time);
disp('*** FINISHED SOLVING STEADY STATE WITH MATCHED VALUE ADDED AND IO SHARES ***');
%% match all expenditure shares

% Intial guess
xi_guess = conssh_data;
mu_guess = ModData.parameters.parmu;
alpha_guess = capsh_data;
Gamma_M_guess = ModData.parameters.parGamma_M(1:params.n_sectors-1, :);
Gamma_M_guess = Gamma_M_guess(:);
Gamma_I_guess = invnet_data(1:params.n_sectors-1, :);
Gamma_I_guess = Gamma_I_guess(:);
sol_guess = [sol_partial(1:11*params.n_sectors+3);log(xi_guess);log(mu_guess);log(alpha_guess);log(Gamma_M_guess);log(Gamma_I_guess)];

% loop over grid of values to get final answer
gridpoints = 8;
sigma_c_grid = linspace(0.5,sigma_c,gridpoints);
sigma_y_grid = linspace(0.99,sigma_y,gridpoints);
sigma_I_grid = linspace(0.99,sigma_I,gridpoints);

total_tic = tic;
for i = 1:gridpoints
    iteration_tic = tic;
    params.sigma_c = sigma_c_grid(i);
    params.sigma_y = sigma_y_grid(i);
    params.sigma_I = sigma_I_grid(i);
    fh_compStSt         = @(x) ProdNetRbc_SS_expshares(x,params, 0);
    [sol_partial,fval,exfl]  = fsolve(fh_compStSt,sol_guess,options);
    [fx,ModData]        = ProdNetRbc_SS_expshares(sol_partial,params,0);
    sol_guess = sol_partial;
    disp(sprintf('For sigma_c = %0.2f, sigma_y = %0.2f and sigma_I = %0.2f : %s',params.sigma_c,params.sigma_y,params.sigma_I,ExitFlag(exfl)));
    iteration_time = toc(iteration_tic);
    fprintf('It took %.4f seconds to run iteration number %d \n', iteration_time,i);
end
elapsed_time = toc(total_tic);
fprintf('It took %.4f seconds to run this loop.\n', elapsed_time);

if save_exper_ind == 1
    sol_guess = sol_partial;
    filename_sol_guess = strcat('output/','sol_guess_sq', num2str(params.sigma_q), '_sl', num2str(params.sigma_l), '_', save_label, '.mat');
    filename_params = strcat('output/','params_', save_label, '.mat');
    save(filename_sol_guess, 'sol_guess');
    save(filename_params, 'params');
end

disp('*** FINISHED SOLVING STEADY STATE ***');
%% save results

% Save data to open in Python
if save_exper_ind == 1
    filename_Mod = strcat('output/RbcProdNet_ModData_', save_label, '.mat');
    save(filename_Mod, 'ModData');
end
 
% Save a matlab structure to pass to dyanre. It needs to have each aprameter as a different variable

policies_ss = ModData.policies_ss;  % Keep this for IR calculations later
k_ss = ModData.endostates_ss;

params_vars = struct2cell(ModData.parameters);
params_names = fieldnames(ModData.parameters);
for i = 1:numel(params_vars)
    assignin('base', params_names{i}, params_vars{i});
end

% Save data to open in Dynare (if you change name, change it in mod file and steady_state files as well)
save ModStruct_temp par* policies_ss k_ss

disp('*** CREATED TEMP STRUCTURE ModStruct_temp TO PASS TO DYNARE ***');
disp('*** STORED THE MODEL INFO IN output/RbcProdNet_ModData_Jan24. ***');

%% Solve Log-Linearized Model in Dynare
tic;
dynare stoch_simul;
elapsed_time = toc;
fprintf('It took %.4f seconds to run.\n', elapsed_time);

% Store aggregate consumption and labor for IR calculations
Cagg_ss = exp(policies_ss(11*parn_sectors+1));
Lagg_ss = exp(policies_ss(11*parn_sectors+2));

clearvars -except oo_ options_  M_ par* ModData policies_ss endostates_ss sector_indices save_exper_ind sector_labels save_label N ax client_indices client_labels ranking labels Cagg_ss Lagg_ss ar1resid* empiricalTargets params k_ss ionet_data
disp('*** FINISHED SOLVING DYNARE MODEL. SOLUTION IS STORED IN oo_ and M_ GLOBALS ***'); 

%% Simulating the model
tic;
dim=parn_sectors;
% params.simul_T = 200;
modorder = 1; % order of the simulation
shockssim = mvnrnd(zeros([parn_sectors,1]),params.Sigma_A,params.simul_T); % 100000 random draws of the shock.
% shockssim = zeros([params.simul_T,37]);
% shockssim(1:70,:) = ar1resid; 
% shockssim = ar1resid; % 100000 random draws of the shock.

ss_values=oo_.steady_state; % get the steafy state 
k_ss = ss_values(1:parn_sectors);
policies_ss_dynare = ss_values(2*parn_sectors+1:13*parn_sectors+5);
% Keep the original policies_ss from ModData for IR calculations
% policies_ss is already set from ModData before Dynare and preserved in clearvars
display([ss_values(2*parn_sectors+1:13*parn_sectors+5),ModData.policies_ss]);

% Simulating using dynare's function simult_
dynare_simul = simult_(M_,options_, oo_.steady_state,oo_.dr,shockssim,modorder);
varlev=exp(dynare_simul(1:13*parn_sectors+5,:)); % variables in levels
variables_var = var(dynare_simul,0,2); % variance

% calculate simulation based variance:
shocks_sd = sqrt(var(shockssim,0,1)).';
states_sd = sqrt(variables_var(1:2*parn_sectors));
policies_sd = sqrt(variables_var(2*parn_sectors+1:13*parn_sectors+5));
% policies_sd(8*parn_sectors+1:9*parn_sectors) = states_sd(parn_sectors+1:2*parn_sectors);


% Simulating using the State Space Representation
[tn,sn] = size(oo_.dr.ghx); % dimensions, tn is total number of variables, sn is number of states

% get the matrices to recover the state space representation 
%S(t) = A*S(t-1) + B*e(t), evolution of the state
%X(t) = C*S(t-1) + D*e(t); evolution of the rest of the variables

% recover position of each variable in state space representation
k_ind = [1,dim];
a_ind = [dim+1,2*dim];
c_ind = [2*dim+1,3*dim];
l_ind = [3*dim+1,4*dim];
pk_ind = [4*dim+1,5*dim];
pm_ind = [5*dim+1,6*dim];
m_ind = [6*dim+1,7*dim];
mout_ind = [7*dim+1,8*dim];
i_ind = [8*dim+1,9*dim];
iout_ind = [9*dim+1,10*dim];
p_ind = [10*dim+1,11*dim];
q_ind = [11*dim+1,12*dim];
y_ind = [12*dim+1,13*dim];
cagg_ind = 13*dim+1;
lagg_ind = 13*dim+2;
yagg_ind = 13*dim+3;
iagg_ind = 13*dim+4;
magg_ind = 13*dim+5;

k_ind_inv = [oo_.dr.inv_order_var(k_ind(1)),oo_.dr.inv_order_var(k_ind(2))];
a_ind_inv = [oo_.dr.inv_order_var(a_ind(1)),oo_.dr.inv_order_var(a_ind(2))];

c_ind_inv = [oo_.dr.inv_order_var(c_ind(1)),oo_.dr.inv_order_var(c_ind(2))];
l_ind_inv = [oo_.dr.inv_order_var(l_ind(1)),oo_.dr.inv_order_var(l_ind(2))];
pk_ind_inv = [oo_.dr.inv_order_var(pk_ind(1)),oo_.dr.inv_order_var(pk_ind(2))];
pm_ind_inv = [oo_.dr.inv_order_var(pm_ind(1)),oo_.dr.inv_order_var(pm_ind(2))];
m_ind_inv = [oo_.dr.inv_order_var(m_ind(1)),oo_.dr.inv_order_var(m_ind(2))];
mout_ind_inv = [oo_.dr.inv_order_var(mout_ind(1)),oo_.dr.inv_order_var(mout_ind(2))];
i_ind_inv = [oo_.dr.inv_order_var(i_ind(1)),oo_.dr.inv_order_var(i_ind(2))];
iout_ind_inv = [oo_.dr.inv_order_var(iout_ind(1)),oo_.dr.inv_order_var(iout_ind(2))];
p_ind_inv = [oo_.dr.inv_order_var(p_ind(1)),oo_.dr.inv_order_var(p_ind(2))];
q_ind_inv = [oo_.dr.inv_order_var(q_ind(1)),oo_.dr.inv_order_var(q_ind(2))];
y_ind_inv = [oo_.dr.inv_order_var(y_ind(1)),oo_.dr.inv_order_var(y_ind(2))];
cagg_ind_inv = oo_.dr.inv_order_var(cagg_ind);
lagg_ind_inv = oo_.dr.inv_order_var(lagg_ind);
yagg_ind_inv = oo_.dr.inv_order_var(yagg_ind);
iagg_ind_inv = oo_.dr.inv_order_var(iagg_ind);
magg_ind_inv = oo_.dr.inv_order_var(magg_ind);


A=[oo_.dr.ghx(k_ind_inv(1):k_ind_inv(2),:); 
   oo_.dr.ghx(a_ind_inv(1):a_ind_inv(2),:)];
B=[oo_.dr.ghu(k_ind_inv(1):k_ind_inv(2),:); 
   oo_.dr.ghu(a_ind_inv(1):a_ind_inv(2),:)];

% We can check that A and B are correct
%get state indices
ipred = M_.nstatic+(1:M_.nspred)';
%get state transition matrices
[A_2,B_2] = kalman_transition_matrix(oo_.dr,ipred,1:M_.nspred,M_.exo_nbr);
disp('Is manually calc. A equal to dynare cal. A?');
disp(isequal(A,A_2));
disp('Is manually calc. B equal to dynare cal. B?');
disp(isequal(B,B_2));

% We construct policy parameters
C =[oo_.dr.ghx(c_ind_inv(1):c_ind_inv(2),:);
         oo_.dr.ghx(l_ind_inv(1):l_ind_inv(2),:);
         oo_.dr.ghx(pk_ind_inv(1):pk_ind_inv(2),:);
         oo_.dr.ghx(pm_ind_inv(1):pm_ind_inv(2),:);
         oo_.dr.ghx(m_ind_inv(1):m_ind_inv(2),:);
         oo_.dr.ghx(mout_ind_inv(1):mout_ind_inv(2),:);
         oo_.dr.ghx(i_ind_inv(1):i_ind_inv(2),:);
         oo_.dr.ghx(iout_ind_inv(1):iout_ind_inv(2),:);
         oo_.dr.ghx(p_ind_inv(1):p_ind_inv(2),:);
         oo_.dr.ghx(q_ind_inv(1):q_ind_inv(2),:);
         oo_.dr.ghx(y_ind_inv(1):y_ind_inv(2),:);
         oo_.dr.ghx(cagg_ind_inv,:);
         oo_.dr.ghx(lagg_ind_inv,:);
         oo_.dr.ghx(yagg_ind_inv,:);
         oo_.dr.ghx(iagg_ind_inv,:);
         oo_.dr.ghx(magg_ind_inv,:)];
D =[oo_.dr.ghu(c_ind_inv(1):c_ind_inv(2),:);
         oo_.dr.ghu(l_ind_inv(1):l_ind_inv(2),:);
         oo_.dr.ghu(pk_ind_inv(1):pk_ind_inv(2),:);
         oo_.dr.ghu(pm_ind_inv(1):pm_ind_inv(2),:);
         oo_.dr.ghu(m_ind_inv(1):m_ind_inv(2),:);
         oo_.dr.ghu(mout_ind_inv(1):mout_ind_inv(2),:);
         oo_.dr.ghu(i_ind_inv(1):i_ind_inv(2),:);
         oo_.dr.ghu(iout_ind_inv(1):iout_ind_inv(2),:);
         oo_.dr.ghu(p_ind_inv(1):p_ind_inv(2),:);
         oo_.dr.ghu(q_ind_inv(1):q_ind_inv(2),:);
         oo_.dr.ghu(y_ind_inv(1):y_ind_inv(2),:);
         oo_.dr.ghu(cagg_ind_inv,:);
         oo_.dr.ghu(lagg_ind_inv,:);
         oo_.dr.ghu(yagg_ind_inv,:);
         oo_.dr.ghu(iagg_ind_inv,:);
         oo_.dr.ghu(magg_ind_inv,:)];


% % store results
% Simul = [A_Simul;Cagg_Simul;Lagg_Simul;Vc_Simul];
% Simul_sd = [sqrt(var(A_Simul,0,2));sqrt(var(Cagg_Simul,0,2))./Cagg_ss;sqrt(var(Lagg_Simul,0,2))./Lagg_ss];

% save resutls
SolData = struct;
SolData.parameters = ModData.parameters;
SolData.k_ss = k_ss;
SolData.policies_ss = policies_ss_dynare;  % Save without welfare (shorter version from Dynare)
SolData.states_sd = states_sd;
SolData.policies_sd = policies_sd;
SolData.shocks_sd = shocks_sd;
SolData.A = A;
SolData.B = B;
SolData.C = C;
SolData.D = D;


if save_exper_ind==1
    filename_Sol = strcat('output/RbcProdNet_SolData_', save_label, '.mat');
    save(filename_Sol, 'SolData');
%     save filename_sol ModData states_sd policies_sd shocks_sd V_ss A B C D Simul Simul_sd
end
shockssim_data = shockssim';
elapsed_time = toc;
fprintf('It took %.4f seconds to run.\n', elapsed_time);
disp('*** FINISHED SIMULATION OF DYNARE POLICIES. ***');

%% Compute Model Statistics and Compare with Empirical Targets
fprintf('\n*** COMPUTING MODEL STATISTICS ***\n');

modelStats = struct();

% Extract simulated series (already in log deviations from SS, i.e., stationary)
k_simul = dynare_simul(k_ind(1):k_ind(2), :);
a_simul = dynare_simul(a_ind(1):a_ind(2), :);
c_simul = dynare_simul(c_ind(1):c_ind(2), :);
l_simul = dynare_simul(l_ind(1):l_ind(2), :);
i_simul = dynare_simul(i_ind(1):i_ind(2), :);
y_simul = dynare_simul(y_ind(1):y_ind(2), :);
cagg_simul = dynare_simul(cagg_ind, :);
yagg_simul = dynare_simul(yagg_ind, :);

% Note: dynare_simul contains log deviations from steady state
% The model is already stationary (no trend), so these are directly comparable
% to HP-filtered data (both are cyclical components)

% Target 1: Aggregate GDP volatility (std of log deviations)
sigmaVA_agg_model = std(yagg_simul);

% Target 2: Aggregate GDP autocorrelation (of log deviations)
rho_VA_agg_model = corr(yagg_simul(1:end-1)', yagg_simul(2:end)');

% Target 3: Sectoral VA comovement (correlation of log deviations)
corr_matrix_VA_model = corr(y_simul');
pairwise_corrs_model = corr_matrix_VA_model(empiricalTargets.upper_tri_idx);
avg_pairwise_corr_VA_model = mean(pairwise_corrs_model);

% Targets 4-5: Investment and labor volatility (std of log deviations)
sigmaIi_model = std(i_simul, 0, 2)';
sigmaLi_model = std(l_simul, 0, 2)';
sigmaI_model = sum(empiricalTargets.weights .* sigmaIi_model);
sigmaL_model = sum(empiricalTargets.weights .* sigmaLi_model);

modelStats.sigmaI = sigmaI_model;
modelStats.sigmaL = sigmaL_model;
modelStats.sigmaVA_agg = sigmaVA_agg_model;
modelStats.rho_VA_agg = rho_VA_agg_model;
modelStats.avg_pairwise_corr_VA = avg_pairwise_corr_VA_model;
modelStats.sigmaIi = sigmaIi_model;
modelStats.sigmaLi = sigmaLi_model;
modelStats.corr_matrix_VA = corr_matrix_VA_model;

fprintf('\n*** MODEL VS EMPIRICAL COMPARISON ***\n');
fprintf('                                          Model        Empirical      Ratio\n');
fprintf('-----------------------------------------------------------------------\n');
fprintf('Aggregate GDP volatility:                 %.4f       %.4f       %.4f\n', ...
    sigmaVA_agg_model, empiricalTargets.sigmaVA_agg, sigmaVA_agg_model/empiricalTargets.sigmaVA_agg);
fprintf('Aggregate GDP autocorrelation:            %.4f       %.4f       %.4f\n', ...
    rho_VA_agg_model, empiricalTargets.rho_VA_agg, rho_VA_agg_model/empiricalTargets.rho_VA_agg);
fprintf('Sectoral VA avg pairwise correlation:     %.4f       %.4f       %.4f\n', ...
    avg_pairwise_corr_VA_model, empiricalTargets.avg_pairwise_corr_VA, avg_pairwise_corr_VA_model/empiricalTargets.avg_pairwise_corr_VA);
fprintf('Weighted investment volatility:           %.4f       %.4f       %.4f\n', ...
    sigmaI_model, empiricalTargets.sigmaI, sigmaI_model/empiricalTargets.sigmaI);
fprintf('Weighted labor volatility:                %.4f       %.4f       %.4f\n', ...
    sigmaL_model, empiricalTargets.sigmaL, sigmaL_model/empiricalTargets.sigmaL);
fprintf('***************************\n\n');

if save_exper_ind == 1
    filename_Stats = strcat('output/ModelStats_', save_label, '.mat');
    save(filename_Stats, 'modelStats', 'empiricalTargets');
end

disp('*** POLICIES AND SIMULATION STATISTICS SOLUTION IS STORED IN output/RbcProdNet_SolData_`savelabel� ***');

%% Compute Standard Deviation of Calibrated Shocks
fprintf('\n*** COMPUTING SHOCK STANDARD DEVIATIONS ***\n');

% Since shocks are potentially correlated, we simulate to get standard deviations
num_simulations_shocks = 10000;
simulated_shocks = mvnrnd(zeros(1, dim), params.Sigma_A, num_simulations_shocks);
shock_std_calibrated = std(simulated_shocks)';

fprintf('Average shock std deviation: %.6f\n', mean(shock_std_calibrated));
fprintf('Min shock std deviation: %.6f\n', min(shock_std_calibrated));
fprintf('Max shock std deviation: %.6f\n', max(shock_std_calibrated));
fprintf('***************************\n\n');

%% Impulse Response Analysis
fprintf('\n*** COMPUTING IMPULSE RESPONSES ***\n');

% IR parameters
N = 60;
ax = 0:N-1;
modorder = 1;
range_padding = 0.1;
steady_state = oo_.steady_state;
big_sector_ind = 0;

% Set longer simulation length for IRs (needs to be longer than N)
params.simul_T = 200;

% Choosing sectors to analyze
if big_sector_ind == 1
    sector_indices = [20, 24];
else
    sector_indices = [1];
end

% Get sector labels
sector_labels = SectorLabel(sector_indices);

% Get maximum client of each sector and ranking of clients
client_indices = zeros(numel(sector_indices),1);
ranking = zeros(numel(sector_indices),params.n_sectors);

for s_idx = sector_indices
    % we exclude the own sector when computing the client
    ionet_without_sector = [ionet_data(s_idx,1:s_idx-1),ionet_data(s_idx,s_idx+1:end)];
    [max_value, col_index] = max(ionet_without_sector);
    if col_index >= s_idx
        col_index = col_index+1;
    end
    client_indices(find(sector_indices == s_idx)) = col_index;
    shares_vector = ionet_data(s_idx,:);
    sorted_ionet = sort(shares_vector,'descend');
    [~, rank] = ismember(shares_vector, sorted_ionet);
    % artificially placing the sector as the 1st in the ranking when it's not
    if rank(s_idx) ~= 1
        rank(rank<rank(s_idx)) = rank(rank<rank(s_idx))+1;
        rank(s_idx) = 1;
    end
    ranking(find(sector_indices == s_idx),:) = rank;
end

client_labels = SectorLabel(client_indices);
labels = {sector_indices, sector_labels, client_indices, client_labels};

% Loop over sectors to compute IRs
for idx = 1:numel(sector_indices)
    sector_idx = sector_indices(idx);
    steady_state_ir = steady_state;
    steady_state_ir(parn_sectors+sector_idx) = -params.IRshock;
    
    % LOG-LINEAR IR
    shockssim_ir = zeros([params.simul_T, parn_sectors]);
    dynare_simul_ir = simult_(M_, options_, steady_state_ir, oo_.dr, shockssim_ir, modorder);
    IRSLoglin = DynareProcessIR(dynare_simul_ir, params, steady_state_ir, labels, parn_sectors, k_ss, Cagg_ss, Lagg_ss, policies_ss);
    
    % DETERMINISTIC IR
    shocksim_0 = zeros([parn_sectors,1]);
    shocksim_0(sector_idx,1) = -params.IRshock;
    shockssim_ir = zeros([params.simul_T, parn_sectors]);
    simul_T = params.simul_T;  % Dynare deterministic needs this in workspace
    dynare determ_irs;
    dynare_simul_determ = Simulated_time_series.data';
    IRSDeterm = DynareProcessIR(dynare_simul_determ, params, steady_state_ir, labels, parn_sectors, k_ss, Cagg_ss, Lagg_ss, policies_ss);
    
    % COBB-DOUGLAS IR (if available)
    if exist('IRSLoglinCD.mat', 'file')
        load('IRSLoglinCD.mat');
    else
        IRSLoglinCD = [];
    end
    
    % Produce & Save the graphs
    GraphIRs(IRSDeterm, IRSLoglin, IRSLoglinCD, ax, N, labels, range_padding, save_label, save_exper_ind);
end

% Save IRs
if save_exper_ind == 1
    IRS = struct();
    IRS.IRSLoglin = IRSLoglin;
    IRS.IRSDeterm = IRSDeterm;
    if ~isempty(IRSLoglinCD)
        IRS.IRSLoglinCD = IRSLoglinCD;
    end
    filename_IRS = strcat('output/IRS_', save_label, '.mat');
    save(filename_IRS, 'IRS');
end

fprintf('*** FINISHED COMPUTING IMPULSE RESPONSES ***\n');

